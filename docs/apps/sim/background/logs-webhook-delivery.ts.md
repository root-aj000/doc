This TypeScript file defines a robust background task for delivering webhooks when a workflow execution in your system completes. It's built using the `@trigger.dev/sdk` which implies it's part of a managed job processing system designed for reliability, retries, and long-running operations.

---

## ðŸ“„ Purpose of This File

The primary purpose of this file is to create and manage the delivery of "workflow execution completed" webhooks to external systems. When a workflow finishes (successfully or with an error), this task is triggered to:

1.  **Construct a detailed payload** about the workflow's outcome.
2.  **Sign the payload** for security and verification by the recipient (if a secret is configured).
3.  **Attempt to deliver the webhook** to the configured URL.
4.  **Implement a sophisticated retry strategy** with exponential backoff and jitter for transient failures (network issues, temporary server outages).
5.  **Record the delivery status** (pending, in\_progress, success, failed) and attempt details in the database.
6.  **Handle timeouts and unexpected errors** gracefully.

In essence, it acts as the "post office" for workflow completion notifications, ensuring they are delivered reliably and securely.

---

## ðŸŽ¯ Simplifying Complex Logic

Let's break down the most complex aspects:

1.  **Atomic Delivery Claiming:**
    *   **Problem:** Multiple instances of this task might try to process the *same* webhook delivery simultaneously (e.g., if a previous attempt failed and the task was re-queued).
    *   **Solution:** The database update that changes the `workflowLogWebhookDelivery` status from `pending` to `in_progress` is designed to be **atomic**. It uses a `WHERE` clause that checks `status = 'pending'` and also ensures the `nextAttemptAt` time has passed. If another task instance already claimed it, or it's not yet time for a retry, the `update` operation will affect zero rows, and the current task instance will gracefully exit, preventing duplicate deliveries or race conditions. The `returning` clause helps retrieve the new `attempts` count after the atomic increment.

2.  **Internal Retry Strategy vs. External Task Retries:**
    *   **Problem:** `@trigger.dev/sdk` provides its own retry mechanism (`retry` option in `task` definition). However, for more fine-grained control (e.g., exponential backoff, jitter, specific HTTP status code handling, and database updates for each attempt), you often need to manage retries *within* the task itself.
    *   **Solution:**
        *   The task is configured with `retry: { maxAttempts: 1 }`. This tells Trigger.dev *not* to automatically retry if the `run` function throws an unhandled error.
        *   Instead, when a retryable error occurs (HTTP 5xx, 429, or network errors/timeouts), the task:
            1.  **Calculates a delay** using `RETRY_DELAYS` (exponential backoff) and `getRetryDelayWithJitter` (adds randomness).
            2.  **Updates the database** to set the delivery status back to `pending` and `nextAttemptAt` to the calculated future time.
            3.  **Uses `await wait.for(...)`** to pause its execution for the calculated delay.
            4.  **Calls `logsWebhookDelivery.trigger(...)` recursively.** This is the key! It re-queues *itself* with the exact same parameters, essentially telling Trigger.dev: "I need to run again later with the same job." This allows Trigger.dev to handle the queuing and resource management for the retry, while the task itself controls the *logic* of when and how to retry.

3.  **Webhook Signature Generation:**
    *   **Problem:** How to ensure the webhook recipient can verify that the request truly came from your system and hasn't been tampered with?
    *   **Solution:** Implement a HMAC (Hash-based Message Authentication Code) signature.
        *   A shared `secret` (known by both sender and receiver) is used.
        *   The signature is generated by hashing a combination of the current timestamp and the request body using `createHmac('sha256', secret)`.
        *   This signature is sent in a custom `sim-signature` header. The recipient can then re-generate the signature with their copy of the secret and compare it to the received signature. If they match, the request is authentic.

---

## ðŸ§‘â€ðŸ’» Line-by-Line Explanation

```typescript
import { createHmac } from 'crypto'
// Imports the createHmac function from Node.js's built-in 'crypto' module.
// Used for cryptographic hashing to generate webhook signatures.

import { db } from '@sim/db'
// Imports the Drizzle ORM database instance, used for all database interactions.

import {
  workflowLogWebhook,
  workflowLogWebhookDelivery,
  workflow as workflowTable,
} from '@sim/db/schema'
// Imports specific table schemas from your Drizzle database.
// - workflowLogWebhook: Represents webhook subscriptions.
// - workflowLogWebhookDelivery: Represents individual webhook delivery attempts.
// - workflowTable: Represents the main workflow definitions (aliased for clarity).

import { task, wait } from '@trigger.dev/sdk'
// Imports components from the Trigger.dev SDK:
// - task: Decorator/function to define a background task.
// - wait: Utility to pause a task for a specified duration.

import { and, eq, isNull, lte, or, sql } from 'drizzle-orm'
// Imports Drizzle ORM query helpers for building complex WHERE clauses:
// - and: Combines multiple conditions with logical AND.
// - eq: Checks for equality.
// - isNull: Checks if a column is NULL.
// - lte: Checks if a column is less than or equal to a value.
// - or: Combines multiple conditions with logical OR.
// - sql: Allows writing raw SQL expressions within Drizzle queries (useful for atomic updates).

import { v4 as uuidv4 } from 'uuid'
// Imports the v4 function from the 'uuid' library to generate universally unique identifiers.

import { createLogger } from '@/lib/logs/console/logger'
// Imports a custom logger utility from your project.

import type { WorkflowExecutionLog } from '@/lib/logs/types'
// Imports the TypeScript type definition for a workflow execution log object.

import { decryptSecret } from '@/lib/utils'
// Imports a utility function to decrypt sensitive secrets (e.g., webhook secrets).

const logger = createLogger('LogsWebhookDelivery')
// Initializes a logger instance specifically for this module, making log messages identifiable.

// Quick retry strategy: 5 attempts over ~15 minutes
// Most webhook failures are transient and resolve quickly
const MAX_ATTEMPTS = 5
// Defines the maximum number of times a webhook delivery will be attempted before failing permanently.

const RETRY_DELAYS = [
  5 * 1000, // 5 seconds (1st retry)
  15 * 1000, // 15 seconds (2nd retry)
  60 * 1000, // 1 minute (3rd retry)
  3 * 60 * 1000, // 3 minutes (4th retry)
  10 * 60 * 1000, // 10 minutes (5th and final retry)
]
// An array defining the delays (in milliseconds) before each subsequent retry attempt.
// This implements an exponential backoff strategy, increasing delay with each attempt.

// Add jitter to prevent thundering herd problem (up to 10% of delay)
function getRetryDelayWithJitter(baseDelay: number): number {
  // A helper function to add a random "jitter" to the base retry delay.
  // Jitter helps prevent multiple concurrent tasks from retrying at the exact same moment,
  // which could overwhelm a recovering external service ("thundering herd" problem).
  const jitter = Math.random() * 0.1 * baseDelay
  // Calculates a random value up to 10% of the base delay.
  return Math.floor(baseDelay + jitter)
  // Returns the base delay plus the jitter, rounded down to an integer.
}

interface WebhookPayload {
  // Defines the TypeScript interface for the structure of the JSON payload sent in the webhook.
  // This ensures type safety and clarity for the data being transmitted.
  id: string
  type: 'workflow.execution.completed'
  timestamp: number
  data: {
    workflowId: string
    executionId: string
    status: 'success' | 'error'
    level: string
    trigger: string
    startedAt: string
    endedAt: string
    totalDurationMs: number
    cost?: any
    files?: any
    finalOutput?: any
    traceSpans?: any[]
    rateLimits?: {
      sync: {
        limit: number
        remaining: number
        resetAt: string
      }
      async: {
        limit: number
        remaining: number
        resetAt: string
      }
    }
    usage?: {
      currentPeriodCost: number
      limit: number
      plan: string
      isExceeded: boolean
    }
  }
  links: {
    log: string
    execution: string
  }
}

function generateSignature(secret: string, timestamp: number, body: string): string {
  // Generates a cryptographic signature for the webhook payload.
  // This allows the recipient to verify the authenticity and integrity of the webhook.
  const signatureBase = `${timestamp}.${body}`
  // Concatenates the timestamp and the raw JSON body to form the base string for the signature.
  const hmac = createHmac('sha256', secret)
  // Creates an HMAC (Hash-based Message Authentication Code) using SHA256 algorithm and a shared secret key.
  hmac.update(signatureBase)
  // Updates the HMAC with the signature base string.
  return hmac.digest('hex')
  // Computes the final HMAC digest and returns it as a hexadecimal string.
}

export const logsWebhookDelivery = task({
  // Defines a Trigger.dev background task named 'logsWebhookDelivery'.
  id: 'logs-webhook-delivery',
  // Unique identifier for this task within Trigger.dev.
  retry: {
    maxAttempts: 1, // We handle retries manually within the task
  },
  // Configures Trigger.dev's built-in retry mechanism.
  // maxAttempts: 1 means Trigger.dev will *not* automatically retry if the `run` function throws an unhandled error.
  // This task implements its own sophisticated retry logic internally.
  run: async (params: {
    deliveryId: string
    subscriptionId: string
    log: WorkflowExecutionLog
  }) => {
    // The main execution function for the task. It's an async function that takes parameters.
    const { deliveryId, subscriptionId, log } = params
    // Destructures the input parameters:
    // - deliveryId: The unique ID for this specific webhook delivery attempt.
    // - subscriptionId: The ID of the webhook subscription this delivery belongs to.
    // - log: The workflow execution log data to be sent in the webhook.

    try {
      // Outer try-catch block to handle any unexpected errors during the entire task execution.

      const [subscription] = await db
        .select()
        .from(workflowLogWebhook)
        .where(eq(workflowLogWebhook.id, subscriptionId))
        .limit(1)
      // Fetches the webhook subscription details from the database based on the subscriptionId.
      // Drizzle's .select() and .from() define the query, .where() filters, and .limit(1) ensures only one record.

      if (!subscription || !subscription.active) {
        // Checks if the subscription exists and is active.
        logger.warn(`Subscription ${subscriptionId} not found or inactive`)
        // Logs a warning if the subscription is not found or inactive.
        await db
          .update(workflowLogWebhookDelivery)
          .set({
            status: 'failed',
            errorMessage: 'Subscription not found or inactive',
            updatedAt: new Date(),
          })
          .where(eq(workflowLogWebhookDelivery.id, deliveryId))
        // Updates the delivery record in the database, marking it as 'failed' with a descriptive error message.
        return
        // Exits the task early as there's nothing further to do.
      }

      // Atomically claim this delivery row for processing and increment attempts
      const claimed = await db
        .update(workflowLogWebhookDelivery)
        .set({
          status: 'in_progress',
          attempts: sql`${workflowLogWebhookDelivery.attempts} + 1`,
          // Atomically increments the 'attempts' counter using a raw SQL expression.
          lastAttemptAt: new Date(),
          updatedAt: new Date(),
        })
        .where(
          // Specifies the conditions for this update to be applied.
          and(
            // Combines multiple conditions with an AND operator.
            eq(workflowLogWebhookDelivery.id, deliveryId),
            // Ensures we're updating the specific delivery record.
            eq(workflowLogWebhookDelivery.status, 'pending'),
            // Crucial for atomicity: only update if the status is currently 'pending'.
            // This prevents multiple task instances from claiming the same delivery simultaneously.
            // Only claim if not scheduled in the future or schedule has arrived
            or(
              // Allows claiming if either condition is true.
              isNull(workflowLogWebhookDelivery.nextAttemptAt),
              // If there's no scheduled next attempt time (first attempt).
              lte(workflowLogWebhookDelivery.nextAttemptAt, new Date())
              // Or if the scheduled next attempt time is in the past or present.
            )
          )
        )
        .returning({ attempts: workflowLogWebhookDelivery.attempts })
      // After the update, returns the new value of the 'attempts' column.
      // If the update affected 0 rows (meaning another task claimed it or it wasn't pending/due), 'claimed' will be empty.

      if (claimed.length === 0) {
        // If the `claimed` array is empty, it means this task instance failed to atomically claim the delivery.
        logger.info(`Delivery ${deliveryId} not claimable (already in progress or not due)`)
        // Logs an informational message.
        return
        // Exits the task, preventing duplicate processing.
      }

      const attempts = claimed[0].attempts
      // Retrieves the current attempt count from the atomically updated record.
      const timestamp = Date.now()
      // Gets the current timestamp in milliseconds.
      const eventId = `evt_${uuidv4()}`
      // Generates a unique event ID for the webhook payload.

      const payload: WebhookPayload = {
        // Constructs the webhook payload object based on the `WorkflowExecutionLog` data.
        id: eventId,
        type: 'workflow.execution.completed', // Fixed event type.
        timestamp,
        data: {
          workflowId: log.workflowId,
          executionId: log.executionId,
          status: log.level === 'error' ? 'error' : 'success',
          // Maps the log's level to a 'status' field (e.g., 'error' or 'success').
          level: log.level,
          trigger: log.trigger,
          startedAt: log.startedAt,
          endedAt: log.endedAt || log.startedAt,
          // Uses `endedAt` if available, otherwise `startedAt` as a fallback.
          totalDurationMs: log.totalDurationMs,
          cost: log.cost,
          files: (log as any).files, // Type assertion for potentially missing 'files' property.
        },
        links: {
          // Provides URLs for related resources.
          log: `/v1/logs/${log.id}`,
          execution: `/v1/logs/executions/${log.executionId}`,
        },
      }

      if (subscription.includeFinalOutput && log.executionData) {
        // Conditionally adds 'finalOutput' to the payload if the subscription requests it
        // and the log data contains 'executionData'.
        payload.data.finalOutput = (log.executionData as any).finalOutput
      }

      if (subscription.includeTraceSpans && log.executionData) {
        // Conditionally adds 'traceSpans' to the payload if the subscription requests it.
        payload.data.traceSpans = (log.executionData as any).traceSpans
      }

      // Fetch rate limits and usage data if requested
      if ((subscription.includeRateLimits || subscription.includeUsageData) && log.executionData) {
        // Checks if either rate limits or usage data are requested by the subscription
        // and if executionData is available.
        const executionData = log.executionData as any

        const needsRateLimits = subscription.includeRateLimits && executionData.includeRateLimits
        const needsUsage = subscription.includeUsageData && executionData.includeUsageData
        if (needsRateLimits || needsUsage) {
          // If either is needed, dynamically import the `getUserLimits` function.
          // Dynamic imports help defer loading of modules until they are actually needed,
          // potentially reducing initial load time or preventing circular dependencies.
          const { getUserLimits } = await import('@/app/api/v1/logs/meta')
          const workflow = await db
            .select()
            .from(workflowTable)
            .where(eq(workflowTable.id, log.workflowId))
            .limit(1)
          // Fetches the workflow details to get the associated userId.

          if (workflow.length > 0) {
            try {
              const limits = await getUserLimits(workflow[0].userId)
              // Calls an external function to fetch user-specific rate limits and usage.
              if (needsRateLimits) {
                payload.data.rateLimits = limits.workflowExecutionRateLimit
                // Adds rate limits to the payload if requested.
              }
              if (needsUsage) {
                payload.data.usage = limits.usage
                // Adds usage data to the payload if requested.
              }
            } catch (error) {
              logger.warn('Failed to fetch limits/usage for webhook', { error })
              // Logs a warning if fetching limits/usage fails, but doesn't stop webhook delivery.
            }
          }
        }
      }

      const body = JSON.stringify(payload)
      // Converts the payload object into a JSON string, which will be the body of the HTTP request.
      const headers: Record<string, string> = {
        // Defines the HTTP headers for the webhook request.
        'Content-Type': 'application/json',
        'sim-event': 'workflow.execution.completed', // Custom header indicating the event type.
        'sim-timestamp': timestamp.toString(), // Custom header for the event timestamp.
        'sim-delivery-id': deliveryId, // Custom header for the delivery ID.
        'Idempotency-Key': deliveryId,
        // An Idempotency-Key ensures that if the same request is sent multiple times,
        // it has the same effect as being sent once, preventing duplicate processing by the recipient.
      }

      if (subscription.secret) {
        // If the subscription has a secret configured, generate and include a signature.
        const { decrypted } = await decryptSecret(subscription.secret)
        // Decrypts the stored secret before use.
        const signature = generateSignature(decrypted, timestamp, body)
        // Generates the HMAC signature.
        headers['sim-signature'] = `t=${timestamp},v1=${signature}`
        // Adds the signature to a custom header, including the timestamp and signature version.
      }

      logger.info(`Attempting webhook delivery ${deliveryId} (attempt ${attempts})`, {
        url: subscription.url,
        executionId: log.executionId,
      })
      // Logs an informational message about the delivery attempt.

      const controller = new AbortController()
      // Creates an AbortController for managing request cancellation (e.g., timeouts).
      const timeoutId = setTimeout(() => controller.abort(), 30000)
      // Sets a 30-second timeout. If the fetch request doesn't complete within this time,
      // `controller.abort()` will be called, causing the fetch to throw an 'AbortError'.

      try {
        // Inner try-catch block specifically for the fetch request and its immediate response handling.
        const response = await fetch(subscription.url, {
          method: 'POST',
          headers,
          body,
          signal: controller.signal,
          // Associates the AbortController's signal with the fetch request, enabling timeout cancellation.
        })

        clearTimeout(timeoutId)
        // Clears the timeout if the fetch request completes before the timeout expires.

        const responseBody = await response.text().catch(() => '')
        // Attempts to read the response body as text. Catches any errors during reading (e.g., no body).
        const truncatedBody = responseBody.slice(0, 1000)
        // Truncates the response body for logging purposes to avoid excessively long entries.

        if (response.ok) {
          // If the HTTP response status is within the 200-299 range (successful).
          await db
            .update(workflowLogWebhookDelivery)
            .set({
              status: 'success',
              attempts,
              lastAttemptAt: new Date(),
              responseStatus: response.status,
              responseBody: truncatedBody,
              errorMessage: null, // Clears any previous error messages.
              updatedAt: new Date(),
            })
            .where(
              and(
                eq(workflowLogWebhookDelivery.id, deliveryId),
                eq(workflowLogWebhookDelivery.status, 'in_progress')
                // Ensures we only update if the status is still 'in_progress' (atomic check).
              )
            )
          // Updates the delivery record to 'success'.

          logger.info(`Webhook delivery ${deliveryId} succeeded`, {
            status: response.status,
            executionId: log.executionId,
          })
          // Logs a success message.

          return { success: true }
          // Returns success status.
        }

        const isRetryable = response.status >= 500 || response.status === 429
        // Determines if the failure is retryable:
        // - HTTP 5xx codes usually indicate server-side errors, which are often transient.
        // - HTTP 429 (Too Many Requests) indicates rate limiting, which suggests a retry after a delay.

        if (!isRetryable || attempts >= MAX_ATTEMPTS) {
          // If the error is not retryable OR if the maximum number of attempts has been reached.
          await db
            .update(workflowLogWebhookDelivery)
            .set({
              status: 'failed',
              attempts,
              lastAttemptAt: new Date(),
              responseStatus: response.status,
              responseBody: truncatedBody,
              errorMessage: `HTTP ${response.status}`,
              updatedAt: new Date(),
            })
            .where(
              and(
                eq(workflowLogWebhookDelivery.id, deliveryId),
                eq(workflowLogWebhookDelivery.status, 'in_progress')
              )
            )
          // Marks the delivery as permanently 'failed'.

          logger.warn(`Webhook delivery ${deliveryId} failed permanently`, {
            status: response.status,
            attempts,
            executionId: log.executionId,
          })
          // Logs a warning about the permanent failure.

          return { success: false }
          // Returns failure status.
        }

        const baseDelay = RETRY_DELAYS[Math.min(attempts - 1, RETRY_DELAYS.length - 1)]
        // Calculates the base delay for the next retry from the RETRY_DELAYS array.
        // Math.min handles cases where 'attempts' might exceed the array length, ensuring it uses the last delay.
        const delayWithJitter = getRetryDelayWithJitter(baseDelay)
        // Adds random jitter to the base delay.
        const nextAttemptAt = new Date(Date.now() + delayWithJitter)
        // Calculates the exact time when the next attempt should occur.

        await db
          .update(workflowLogWebhookDelivery)
          .set({
            status: 'pending', // Sets status back to pending for retry.
            attempts,
            lastAttemptAt: new Date(),
            nextAttemptAt, // Schedules the next attempt.
            responseStatus: response.status,
            responseBody: truncatedBody,
            errorMessage: `HTTP ${response.status} - will retry`,
            updatedAt: new Date(),
          })
          .where(
            and(
              eq(workflowLogWebhookDelivery.id, deliveryId),
              eq(workflowLogWebhookDelivery.status, 'in_progress')
            )
          )
        // Updates the delivery record, setting its status to 'pending' and scheduling the next attempt.

        // Schedule the next retry
        await wait.for({ seconds: delayWithJitter / 1000 })
        // Pauses the current task execution for the calculated delay using Trigger.dev's 'wait' utility.
        // This is important because Trigger.dev can checkpoint the task state during this wait.

        // Recursively call the task for retry
        await logsWebhookDelivery.trigger({
          deliveryId,
          subscriptionId,
          log,
        })
        // *Crucial for internal retries*: This line re-triggers (re-queues) the same task
        // with the same parameters. Trigger.dev will then pick it up again when its turn comes.

        return { success: false, retrying: true }
        // Indicates that the delivery failed but a retry has been scheduled.
      } catch (error: any) {
        // Catches errors that occur during the `fetch` operation itself (e.g., network errors, timeouts).
        clearTimeout(timeoutId)
        // Clears the timeout in case an error occurred before the timeout finished.

        if (error.name === 'AbortError') {
          // Specifically handles timeout errors (which are AbortErrors from the AbortController).
          logger.error(`Webhook delivery ${deliveryId} timed out`, {
            executionId: log.executionId,
            attempts,
          })
          error.message = 'Request timeout after 30 seconds'
          // Overwrites the error message for clarity.
        }

        // Apply same retry logic as for HTTP failures
        const baseDelay = RETRY_DELAYS[Math.min(attempts - 1, RETRY_DELAYS.length - 1)]
        const delayWithJitter = getRetryDelayWithJitter(baseDelay)
        const nextAttemptAt = new Date(Date.now() + delayWithJitter)

        await db
          .update(workflowLogWebhookDelivery)
          .set({
            status: attempts >= MAX_ATTEMPTS ? 'failed' : 'pending',
            // Sets status to 'failed' if max attempts reached, otherwise 'pending'.
            attempts,
            lastAttemptAt: new Date(),
            nextAttemptAt: attempts >= MAX_ATTEMPTS ? null : nextAttemptAt,
            // Clears 'nextAttemptAt' if permanently failed.
            errorMessage: error.message,
            updatedAt: new Date(),
          })
          .where(
            and(
              eq(workflowLogWebhookDelivery.id, deliveryId),
              eq(workflowLogWebhookDelivery.status, 'in_progress')
            )
          )
        // Updates the delivery record based on retry logic or permanent failure.

        if (attempts >= MAX_ATTEMPTS) {
          // If max attempts have been reached after this error.
          logger.error(`Webhook delivery ${deliveryId} failed after ${attempts} attempts`, {
            error: error.message,
            executionId: log.executionId,
          })
          return { success: false }
          // Returns failure status.
        }

        // Schedule the next retry
        await wait.for({ seconds: delayWithJitter / 1000 })
        // Pauses the task.

        // Recursively call the task for retry
        await logsWebhookDelivery.trigger({
          deliveryId,
          subscriptionId,
          log,
        })
        // Re-triggers the task for another attempt.

        return { success: false, retrying: true }
        // Returns failure status with retry scheduled.
      }
    } catch (error: any) {
      // This is the outer catch block, handling any unexpected errors that were not
      // caught by the inner try-catch for the fetch operation itself.
      logger.error(`Webhook delivery ${deliveryId} encountered unexpected error`, {
        error: error.message,
        stack: error.stack,
      })
      // Logs the unexpected error, including stack trace for debugging.

      // Mark as failed for unexpected errors
      await db
        .update(workflowLogWebhookDelivery)
        .set({
          status: 'failed',
          errorMessage: `Unexpected error: ${error.message}`,
          updatedAt: new Date(),
        })
        .where(eq(workflowLogWebhookDelivery.id, deliveryId))
      // Marks the delivery as 'failed' in the database due to an unexpected, unhandled error.

      return { success: false, error: error.message }
      // Returns failure status with the error message.
    }
  },
})
// End of Trigger.dev task definition.
```
This TypeScript file defines a "Supabase" block for a larger application, likely a workflow builder or an AI orchestration platform. It's not executable code in itself, but rather a configuration object that tells the application how to display, validate, and interact with a Supabase database integration.

---

### **1. Purpose of This File**

This file, `supabase.ts`, serves as the **blueprint** for a "Supabase" block within an application. Imagine you're building a drag-and-drop workflow tool. This file specifies:

*   **Its Identity**: What it's called, its description, and how it looks (icon, color).
*   **User Interface**: What input fields users will see (e.g., project ID, table name, operation type like "Get Many Rows" or "Create a Row").
*   **Authentication**: How it authenticates with Supabase (using an API key).
*   **Behavior**: How the user's input maps to actual Supabase database operations (e.g., calling a `supabase_query` tool).
*   **Input/Output Schema**: What data it expects as input and what kind of data it will produce as output, helping other blocks or AI understand how to interact with it.
*   **AI Assistance**: For complex fields like filters, it provides a detailed prompt to guide an AI in generating correct syntax, making it easier for users.

In essence, it's a declarative definition that enables the application to dynamically render and manage a robust Supabase integration without needing to hardcode its behavior everywhere.

---

### **2. Simplifying Complex Logic**

The most complex parts of this file are:

1.  **`subBlocks` Array**: This array defines the actual interactive elements (inputs, dropdowns) that a user sees. The complexity comes from conditional rendering (`condition` property) and AI assistance (`wandConfig`).
    *   **Conditional Rendering**: Some input fields only appear when a specific "operation" (like "create" or "update") is selected. For example, the `Data` input only shows up if you choose "Create a Row."
    *   **AI Assistance (`wandConfig`)**: For fields requiring specialized syntax (like database filters), a `wandConfig` property provides a detailed prompt to an AI. This AI can then help the user by generating the correct filter expression based on a natural language request, simplifying a potentially tricky task.

2.  **`tools.config.params` Function**: This function is crucial for transforming the raw user input from the UI into a format suitable for the actual backend Supabase API calls.
    *   **JSON Parsing**: It takes the `data` field (which users might enter as a stringified JSON) and attempts to parse it into a real JavaScript object. It includes robust error handling for invalid JSON.
    *   **Filter Passthrough**: It ensures that the PostgREST filter string entered by the user (or generated by the AI) is passed directly to the Supabase tool without modification.
    *   **Dynamic Parameters**: It intelligently constructs the final parameters object, only including values that are actually provided by the user, ensuring the backend receives clean, relevant data.

By understanding these two main areas, you grasp how user interactions are translated into structured data and then into backend actions, often with AI's help for complex inputs.

---

### **3. Explanation of Each Line of Code**

Let's go through the file section by section.

#### **Imports and Logger Setup**

```typescript
import { SupabaseIcon } from '@/components/icons'
import { createLogger } from '@/lib/logs/console/logger'
import { AuthMode, type BlockConfig } from '@/blocks/types'
import type { SupabaseResponse } from '@/tools/supabase/types'

const logger = createLogger('SupabaseBlock')
```

*   `import { SupabaseIcon } from '@/components/icons'`: Imports a React component named `SupabaseIcon`. This icon will likely be displayed alongside the "Supabase" block in the application's user interface to visually represent it.
*   `import { createLogger } from '@/lib/logs/console/logger'`: Imports a utility function `createLogger` from a logging library. This allows the block definition itself to have its own dedicated logger instance.
*   `import { AuthMode, type BlockConfig } from '@/blocks/types'`: Imports two things:
    *   `AuthMode`: An enum (enumeration) defining different types of authentication methods the block might support (e.g., API Key, OAuth).
    *   `type BlockConfig`: A TypeScript type definition. This is the core type that `SupabaseBlock` must conform to, ensuring it has all the necessary properties to be a valid block in the system.
*   `import type { SupabaseResponse } from '@/tools/supabase/types'`: Imports a TypeScript type `SupabaseResponse`. This specifies the expected structure of the data that this Supabase block will *output*. The `type` keyword indicates this is solely for type checking and won't generate JavaScript code.
*   `const logger = createLogger('SupabaseBlock')`: Initializes a logger instance specifically for this Supabase block, making it easy to trace logs related to its definition or runtime behavior.

#### **`SupabaseBlock` Object - General Configuration**

This is the main export of the file, defining the Supabase block.

```typescript
export const SupabaseBlock: BlockConfig<SupabaseResponse> = {
  type: 'supabase',
  name: 'Supabase',
  description: 'Use Supabase database',
  authMode: AuthMode.ApiKey,
  longDescription:
    'Integrate Supabase into the workflow. Can get many rows, get, create, update, delete, and upsert a row.',
  docsLink: 'https://docs.sim.ai/tools/supabase',
  category: 'tools',
  bgColor: '#1C1C1C',
  icon: SupabaseIcon,
  // ... rest of the block definition
}
```

*   `export const SupabaseBlock: BlockConfig<SupabaseResponse> = { ... }`: Declares and exports a constant `SupabaseBlock`. It's explicitly typed as `BlockConfig<SupabaseResponse>`, meaning it's a block configuration that will produce an output matching the `SupabaseResponse` type.
*   `type: 'supabase'`: A unique identifier for this block type.
*   `name: 'Supabase'`: The user-friendly name displayed for the block in the UI.
*   `description: 'Use Supabase database'`: A short description shown in the UI, perhaps when hovering over the block.
*   `authMode: AuthMode.ApiKey`: Specifies that this block uses an API key for authentication with Supabase. The application will know to ask the user for an API key.
*   `longDescription: 'Integrate Supabase into the workflow. Can get many rows, get, create, update, delete, and upsert a row.'`: A more detailed explanation of what the block does, potentially shown in a modal or documentation panel. It highlights the various database operations supported.
*   `docsLink: 'https://docs.sim.ai/tools/supabase'`: A URL pointing to external documentation for this Supabase integration, useful for users needing more information.
*   `category: 'tools'`: Categorizes this block under "tools" within the application's block library, helping users find it.
*   `bgColor: '#1C1C1C'`: Defines the background color for the block in the UI, likely a dark grey.
*   `icon: SupabaseIcon`: Assigns the previously imported `SupabaseIcon` component to represent this block visually.

#### **`subBlocks` - User Interface Configuration**

This array defines the specific input fields and UI elements users interact with.

```typescript
  subBlocks: [
    {
      id: 'operation',
      title: 'Operation',
      type: 'dropdown',
      layout: 'full',
      options: [
        { label: 'Get Many Rows', id: 'query' },
        { label: 'Get a Row', id: 'get_row' },
        { label: 'Create a Row', id: 'insert' },
        { label: 'Update a Row', id: 'update' },
        { label: 'Delete a Row', id: 'delete' },
        { label: 'Upsert a Row', id: 'upsert' },
      ],
      value: () => 'query',
    },
    // ... other subBlocks
  ],
```

*   **`subBlocks`**: An array containing definitions for all the interactive components that make up the block's configuration interface.
*   **Operation Dropdown**:
    *   `id: 'operation'`: A unique identifier for this input field, used to reference its value.
    *   `title: 'Operation'`: The label displayed to the user for this field.
    *   `type: 'dropdown'`: Specifies that this is a dropdown (select) input.
    *   `layout: 'full'`: Indicates the field should take up the full available width in the UI.
    *   `options: [...]`: An array defining the choices available in the dropdown. Each option has a `label` (what the user sees) and an `id` (the actual value passed internally). This list includes various Supabase operations like `query`, `get_row`, `insert`, `update`, `delete`, and `upsert`.
    *   `value: () => 'query'`: Sets the default selected value for the dropdown to `'query'` (Get Many Rows).

```typescript
    {
      id: 'projectId',
      title: 'Project ID',
      type: 'short-input',
      layout: 'full',
      password: true,
      placeholder: 'Your Supabase project ID (e.g., jdrkgepadsdopsntdlom)',
      required: true,
    },
    {
      id: 'table',
      title: 'Table',
      type: 'short-input',
      layout: 'full',
      placeholder: 'Name of the table',
      required: true,
    },
    {
      id: 'apiKey',
      title: 'Service Role Secret',
      type: 'short-input',
      layout: 'full',
      placeholder: 'Your Supabase service role secret key',
      password: true,
      required: true,
    },
```

*   **Project ID, Table, API Key Inputs**: These are straightforward text input fields.
    *   `id`, `title`, `type`, `layout`: Similar to the operation dropdown. `type: 'short-input'` means a single-line text input.
    *   `password: true`: For `projectId` and `apiKey`, this property indicates that the input should be obscured (like a password field) in the UI, protecting sensitive information.
    *   `placeholder`: Text displayed inside the input field when it's empty, guiding the user on what to enter.
    *   `required: true`: Marks these fields as mandatory.

```typescript
    // Data input for create/update operations
    {
      id: 'data',
      title: 'Data',
      type: 'code',
      layout: 'full',
      placeholder: '{\n  "column1": "value1",\n  "column2": "value2"\n}',
      condition: { field: 'operation', value: 'insert' },
      required: true,
    },
    {
      id: 'data',
      title: 'Data',
      type: 'code',
      layout: 'full',
      placeholder: '{\n  "column1": "value1",\n  "column2": "value2"\n}',
      condition: { field: 'operation', value: 'update' },
      required: true,
    },
    {
      id: 'data',
      title: 'Data',
      type: 'code',
      layout: 'full',
      placeholder: '{\n  "column1": "value1",\n  "column2": "value2"\n}',
      condition: { field: 'operation', value: 'upsert' },
      required: true,
    },
```

*   **Data Input (Repeated for `insert`, `update`, `upsert`)**:
    *   `id: 'data'`: The identifier for this field. Notice it's the same for three different definitions.
    *   `type: 'code'`: This likely means a multi-line input field optimized for code (like JSON), possibly with syntax highlighting.
    *   `placeholder`: Provides an example of JSON structure for data input. `\n` creates newlines for better formatting in the placeholder.
    *   `condition: { field: 'operation', value: 'insert' }`: **This is key.** This field will *only* be visible in the UI when the `operation` dropdown (defined earlier) has its value set to `'insert'`. The other two `data` blocks appear conditionally for `'update'` and `'upsert'` operations, making the UI dynamic and context-aware.
    *   `required: true`: Data is mandatory for these operations.

```typescript
    // Filter for get_row, update, delete operations (required)
    {
      id: 'filter',
      title: 'Filter (PostgREST syntax)',
      type: 'short-input',
      layout: 'full',
      placeholder: 'id=eq.123',
      condition: { field: 'operation', value: 'get_row' },
      required: true,
      wandConfig: {
        enabled: true,
        maintainHistory: true,
        prompt: `You are an expert in PostgREST API syntax. ...`, // Long AI prompt
        placeholder: 'Describe the filter condition you need...',
        generationType: 'postgrest',
      },
    },
    // ... three more identical 'filter' blocks with different conditions
```

*   **Filter Input (Repeated for `get_row`, `update`, `delete`, `query`)**:
    *   `id: 'filter'`: Identifier for the filter field. Like `data`, it's repeated.
    *   `title: 'Filter (PostgREST syntax)'`: Clearly indicates the required syntax.
    *   `condition: { field: 'operation', value: 'get_row' }`: This filter field appears conditionally for `get_row`, `update`, `delete` (where it's `required: true`), and `query` (where it's optional, `required: false` implied by absence).
    *   `wandConfig: { ... }`: This is the AI assistance configuration.
        *   `enabled: true`: Activates the AI "wand" feature for this input.
        *   `maintainHistory: true`: The AI remembers previous interactions or context.
        *   `prompt: \`...\``: A multi-line string containing detailed instructions for an AI model. It explains what PostgREST syntax is, lists operators, gives examples, and sets a critical instruction to *only* return the filter expression. This guides the AI to help users construct correct database filters based on natural language input.
        *   `placeholder: 'Describe the filter condition you need...'`: Text displayed in the AI assistance interface.
        *   `generationType: 'postgrest'`: Specifies the type of content the AI is expected to generate, allowing the application to categorize or optimize its handling.

```typescript
    // Optional order by for query operation
    {
      id: 'orderBy',
      title: 'Order By',
      type: 'short-input',
      layout: 'full',
      placeholder: 'column_name (add DESC for descending)',
      condition: { field: 'operation', value: 'query' },
    },
    // Optional limit for query operation
    {
      id: 'limit',
      title: 'Limit',
      type: 'short-input',
      layout: 'full',
      placeholder: '100',
      condition: { field: 'operation', value: 'query' },
    },
  ], // End of subBlocks array
```

*   **Order By and Limit Inputs (for `query`)**:
    *   These are `short-input` fields that only appear when the `operation` is set to `'query'`.
    *   `orderBy`: For specifying a column to sort by, with a note about `DESC` for descending order.
    *   `limit`: For restricting the number of results, with a default `placeholder` of '100'.
    *   Neither is `required: true`, making them optional for query operations.

#### **`tools` - Backend Integration Logic**

This section defines how the block interacts with the actual backend "tools" or APIs.

```typescript
  tools: {
    access: [
      'supabase_query',
      'supabase_insert',
      'supabase_get_row',
      'supabase_update',
      'supabase_delete',
      'supabase_upsert',
    ],
    config: {
      tool: (params) => {
        switch (params.operation) {
          case 'query':
            return 'supabase_query'
          case 'insert':
            return 'supabase_insert'
          case 'get_row':
            return 'supabase_get_row'
          case 'update':
            return 'supabase_update'
          case 'delete':
            return 'supabase_delete'
          case 'upsert':
            return 'supabase_upsert'
          default:
            throw new Error(`Invalid Supabase operation: ${params.operation}`)
        }
      },
      params: (params) => {
        const { operation, data, filter, ...rest } = params

        // Parse JSON data if it's a string
        let parsedData
        if (data && typeof data === 'string' && data.trim()) {
          try {
            parsedData = JSON.parse(data)
          } catch (parseError) {
            // Provide more detailed error information
            const errorMsg = parseError instanceof Error ? parseError.message : 'Unknown JSON error'
            throw new Error(
              `Invalid JSON data format: ${errorMsg}. Please check your JSON syntax (e.g., strings must be quoted like "value").`
            )
          }
        } else if (data && typeof data === 'object') {
          parsedData = data
        }

        // Handle filter - just pass through PostgREST syntax
        let parsedFilter
        if (filter && typeof filter === 'string' && filter.trim()) {
          parsedFilter = filter.trim()
        }

        // Build params object, only including defined values
        const result = { ...rest }

        if (parsedData !== undefined) {
          result.data = parsedData
        }

        if (parsedFilter !== undefined && parsedFilter !== '') {
          result.filter = parsedFilter
        }

        return result
      },
    },
  },
```

*   **`tools`**: An object configuring how this block interacts with underlying "tools" (backend functions or microservices).
*   `access: [...]`: A list of backend tool identifiers that this block is authorized to call. This defines which specific Supabase-related operations are available to this block.
*   `config: { ... }`: Contains two key functions:
    *   `tool: (params) => { ... }`: This function determines *which* specific backend tool to call based on the user's selected `operation`.
        *   It takes `params` (the block's input values) and uses a `switch` statement on `params.operation`.
        *   For each supported `operation` (e.g., `'query'`, `'insert'`), it returns the corresponding backend tool ID (e.g., `'supabase_query'`, `'supabase_insert'`).
        *   If an unknown `operation` is provided, it throws an error.
    *   `params: (params) => { ... }`: This function processes and transforms the raw parameters received from the UI into a format suitable for the chosen backend tool.
        *   `const { operation, data, filter, ...rest } = params`: Uses object destructuring to extract `operation`, `data`, and `filter` fields, putting all other parameters into the `rest` variable.
        *   **JSON Parsing for `data`**:
            *   Checks if `data` exists, is a string, and not empty.
            *   If so, it attempts `JSON.parse(data)`. This is critical because `data` from a `type: 'code'` UI input often comes as a string, even if it represents JSON.
            *   Includes a `try...catch` block to gracefully handle invalid JSON input, throwing a user-friendly error.
            *   If `data` is already an object (e.g., if it came from another block's output), it's used directly.
        *   **Filter Handling**:
            *   Checks if `filter` exists, is a string, and not empty.
            *   If so, it `trim()`s whitespace and assigns it to `parsedFilter`. The filter string is passed as-is, as it's expected to be in PostgREST syntax already.
        *   **Building `result`**:
            *   `const result = { ...rest }`: Starts building the `result` object by including all parameters from `rest` (e.g., `projectId`, `table`, `apiKey`, `orderBy`, `limit`).
            *   `if (parsedData !== undefined) { result.data = parsedData }`: If `parsedData` (the potentially parsed JSON object) is defined, it's added to `result`. This ensures `data` is only included for operations that require it.
            *   `if (parsedFilter !== undefined && parsedFilter !== '') { result.filter = parsedFilter }`: If `parsedFilter` is defined and not an empty string, it's added to `result`.
            *   `return result`: Returns the final, processed parameter object ready to be sent to the backend Supabase tool.

#### **`inputs` - API Input Schema**

```typescript
  inputs: {
    operation: { type: 'string', description: 'Operation to perform' },
    projectId: { type: 'string', description: 'Supabase project identifier' },
    table: { type: 'string', description: 'Database table name' },
    apiKey: { type: 'string', description: 'Service role secret key' },
    // Data for insert/update operations
    data: { type: 'json', description: 'Row data' },
    // Filter for operations
    filter: { type: 'string', description: 'PostgREST filter syntax' },
    // Query operation inputs
    orderBy: { type: 'string', description: 'Sort column' },
    limit: { type: 'number', description: 'Result limit' },
  },
```

*   **`inputs`**: An object defining the schema for the *inputs* that this block expects *programmatically* (e.g., if another block or an AI provides data to it). This is distinct from `subBlocks` which define the *UI inputs*.
*   Each property (e.g., `operation`, `projectId`, `data`) defines an expected input.
    *   `type`: The data type of the input (e.g., `'string'`, `'json'`, `'number'`).
    *   `description`: A human-readable explanation of what the input represents. This is crucial for AI or other developers to understand how to use the block.

#### **`outputs` - API Output Schema**

```typescript
  outputs: {
    message: {
      type: 'string',
      description: 'Success or error message describing the operation outcome',
    },
    results: {
      type: 'json',
      description: 'Database records returned from query, insert, update, or delete operations',
    },
  },
```

*   **`outputs`**: An object defining the schema for the *outputs* that this block will produce. This tells other parts of the system what kind of data to expect from the Supabase block after it executes.
*   `message`:
    *   `type: 'string'`: Expected to be a string.
    *   `description`: Provides a status message.
*   `results`:
    *   `type: 'json'`: Expected to be a JSON object or array.
    *   `description`: Contains the actual data returned by the Supabase operation (e.g., queried rows, the inserted row, etc.).

---

### **Summary**

This `supabase.ts` file is a comprehensive configuration that defines a "Supabase" block. It meticulously outlines its appearance and behavior within a larger application, enabling users to interact with Supabase databases through a user-friendly interface. It also provides the necessary machinery to translate those user interactions into actual backend database calls, complete with intelligent parameter handling and AI-driven assistance for complex inputs like database filters. This modular approach makes the application flexible, extensible, and easier for both developers and end-users to manage integrations.